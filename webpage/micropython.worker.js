import FileSystem from "./modules/FileSystem.mjs";

import LlvmBoxProcess from "./modules/LlvmBoxProcess.mjs";
import Python3Process from "./modules/Python3Process.mjs";
import MakeProcess from "./modules/MakeProcess.mjs";
import MpyCrossProcess from "./modules/MpyCrossProcess.mjs";
import StdIn from "./stdin.mjs";

class MicroPython {
    initialised = false;

    constructor(){
        this.init();
    }

    fileSystem = null;
    tools = {};
    LLVMStdio;

    async init() {
        // Store the FileSystem in the GlobalWorkerSpace, this is useful
        // for when Wasm modules invoke other Wasm modules.
        const fileSystem = await new FileSystem();
        self.fileSystem = fileSystem;
        self.buffer = [];

        // Populate FS and sync.
        await fileSystem.unpack("./archive.tar.xz");
        await fileSystem.pull();
        
        // Create WebAssembly modules, using Emscripten generated files.
        // Wait for instantiation to complete. Store in GlobalWorkerSpace.
        const tools = {
            "llvm-box": new LlvmBoxProcess({FS: fileSystem.FS, noFSInit: true}),
            "python": new Python3Process({FS: fileSystem.FS, onrunprocess: mPY.runHelper}),
            "pythonH": new Python3Process({FS: fileSystem.FS, onrunprocess: mPY.runHelper}),
            "make": new MakeProcess({FS: fileSystem.FS}),
            "mpy-cross": new MpyCrossProcess({FS: fileSystem.FS}),
        };
        for (let tool in tools) {
            await tools[tool];
            // Remove WASM binary from FileSystem once instantiated
            if(!tool.includes("python")) fileSystem.delete("/wasm/"+tool+".wasm");
        };
        // Only remove python.wasm once both processes have been invoked.
        fileSystem.delete("/wasm/python.wasm");
        self.tools = tools;

        // Overwrite normal stdin functionality for "llvm-box" wasm
        let stdin = new StdIn();
        self.tools["llvm-box"]._module.FS.init(stdin.get, undefined, undefined);

        // Faking microbitversion.h, and mpversion.h. GIT is invoked to generate these which we don't have. 
        // TODO sync this upto real time, maybe try and get git version automatically too
        fileSystem.mkdirTree('/src/codal_port/build/genhdr')
        await fileSystem.writeFile('src/codal_port/build/genhdr/mpversion.h', 
                                        '// This file was generated by py/makeversionhdr.py\n'+
                                        '#define MICROPY_GIT_TAG "v1.20.0-dirty"\n'+
                                        '#define MICROPY_GIT_HASH "294baf52b-dirty"\n'+
                                        '#define MICROPY_BUILD_DATE "2023-07-25"');

        await fileSystem.writeFile('src/codal_port/build/genhdr/microbitversion.h',
                                        '// This file was generated by py/makeversionhdr.py\n'+
                                        '#define MICROBIT_GIT_TAG "v1.20.0"\n'+
                                        '#define MICROBIT_GIT_HASH "294baf52b"\n'+
                                        '#define MICROBIT_BUILD_DATE "2023-07-25"');
        this.initialised = true;

        self.postMessage({origin:"log", body:"Ready"});
        
        self.postMessage({
            origin: "pyfile",
            body: String.fromCharCode(...fileSystem.readFile("/src/codal_port/manifest.py"))
        })

        self.postMessage({
            origin: "cfile",
            body: String.fromCharCode(...fileSystem.readFile("/src/codal_port/Makefile"))
        })
    };

    runHelper(args){
        // This is for the current Stdin implementation which may change. Some commands to build micropython use the
        // pipeline operator " | ". If this is the case we need the stdout of the previous command to be the stdin of the next. 
        // Store the stdout, from the python generated file "stream", in a buffer to read in the future. 
        if(self.fileSystem.FS.analyzePath("/src/codal_port/stream")?.object?.contents){
            self.buffer = Array.from(self.fileSystem.FS.analyzePath("/src/codal_port/stream").object.contents);
        }

        // To save us having a custom MakeFile which doesn't build any of this.
        if(args.includes("makeversionhdr.py") || args.includes("microbitversion.h.pre") || args.includes("test")){
            return "Git Commands breaking things, ignoring";
        }

        // Below is a hacky way to parse bash commands, it will be custom to the commands we are using. 
        // Maybe some wasm based things can be done to replace this? 
        
        // This is used to tell users an error occured, and show some help, removing for now.
        if(args.includes(" || ")){ 
            args = args.split(" || "); 
            return mPY.run(args[0]);
        }
        // " | " each command reads the output of the previous. This is handled in python.
        // Also handles redirecting stdout.
        else if(args.includes(" | ") || args.includes(" > ")){
            args = "pythonH utils.py "+args;
            return mPY.run(args);
        }
        // Quotation marks are breaking things here for whatever reason. As we know that all the 
        // directories contain no spaces this seems sensible to change.
        if(args.includes("makemanifest.py")) args = args.replaceAll('"','')
        // Default case
        return mPY.run(args);
    }

    run(args) {
        if((typeof args) === "string") args = args.split(/ +/g);
        
        // Again, to save changing the makefiles, we can just parse the command here. Giving a suitable LLVM
        // replacement command to GCC
        let process = "llvm-box"; // Assume process is LLVM
        switch (args[0]){
            case "arm-none-eabi-as"  : args.shift(); args.unshift("clang", "--target=thumbv7m-none-eabi", "-c"); break; // Slightly more involved as LLVM has an internal assembler.
            case "arm-none-eabi-gcc" : args.shift(); args.unshift(...replaceGCC); break;
            case "arm-none-eabi-ar"  : args[0] = "llvm-ar"; break;
            case "ld.lld"            : break;
            case "llvm-objcopy"      : break;
            default                  : process = null; break; // If none of the above, LLVM isnt running
        }

        let cd = "";
        switch (args[0]){
            case "make"    : process = "make";     break;
            case "python"  : process = "python";   break;
            case "pythonH" : process = "pythonH";  args[0] = "python"; break; // Python Helper, so Python can invkoke python.
            
            case "/lib/micropython/mpy-cross/build/mpy-cross"    : process = "mpy-cross";     break;
            case ""        : process = "pythonH";  args[0] = "python"; break; // TODO, figure out why mpy-tool.py script has nothing for arg[0].
            
            case "cp"      : return;                       // Ignoring CP for now, not required. Could pipe this into busy box?
            case "mkdir"   : return this.makeDir(args);    // mkdir replacement.
            default        : if(process == null) return ;  // TODO Error handling.
        }

        console.log(args.join());

        let p = self.tools[process].exec(args, {
            print: () => () => {},
            printErr: () => () => {},
            cwd: "/src/codal_port".concat(cd)
        })

        console.log(p);

        return p;
    };

    // chmod has to be applied to certain generated files to give us permission to read.
    async getHex(){
        self.fileSystem.FS.chmod("/src/codal_port/MICROBIT.hex", 0o0444);
        return self.fileSystem.readFile("/src/codal_port/MICROBIT.hex")
    };

    async saveFiles(files) {
        for (let f in files) {
            this.saveFile(f, files[f]);
        }
    }

    async saveFile(name, contents){
        await self.fileSystem.writeFile('/working/'+name,contents);
    };

    makeDir(args){
        let dirToMake = "/src/codal_port/"+args[2];
        self.fileSystem.mkdirTree(dirToMake);
        return "mkdir"+dirToMake;
    }
}

// Look into picolibc here, it may not end up being used but it could fix this mess
const replaceGCC = ['clang','--target=arm-none-eabi','-I/include','-I/include/arm-none-eabi-c++/c++/10.3.1',
'-I/include/arm-none-eabi-c++','-I/include/arm-none-eabi-c++/arm-none-eabi/thumb/v7e-m+fp/softfp','-I/include/arm-none-eabi-c++/c++/10.3.1/arm-none-eabi',
'-I/include/arm-none-eabi-c++/backward','-I/include/arm-none-eabi/include','-I/include/arm-none-eabi/include-fixed']

function buildMicropython() {
    self.postMessage({origin:"log", body:"Running Make"})

    // Using GNU Make, execute a dry-run, to later pipe all of these commands through llvm.run(),
    let dryrun = mPY.run("make PYTHON=python --dry-run -s");

    // Turn into an array, delimited by \n
    dryrun = dryrun.stdout.split("\n");
    
    // First element isnt relevant to build.
    dryrun.shift()
    
    // TODO, this removes comments which are for some reason returned by the dryrun, maybe a flag changes this?
    dryrun = dryrun.filter(function (item) {
        return item.indexOf("#") !== 0;
    });

    // TODO, this removes any 'touch' command, dont have this avaliable in wasm. Busybox could offer this functionality 
    dryrun = dryrun.filter(function (item) {
        return item.indexOf("touch") !== 0;
    });

    // Send each element in dry run for processing.
    for(let index in dryrun){
        // Return build info to user.
        if(dryrun[index].includes("GEN") ||
            dryrun[index].includes("CC") || 
            dryrun[index].includes("AS")) self.postMessage({origin:"log", body:dryrun[index].replace("echo ", "")});
        else{ 
            let out = mPY.runHelper(dryrun[index]);
            if(out?.stdout) self.postMessage({origin:"log", body:out.stdout});
            // Stop If an error is encountered
            if(out?.stderr){
                self.postMessage({origin: "log", body: out.stderr});
                return;
            };
        }
    }

    // Look into making this smaller, possibly building arm-llvm but this is a future goal
    mPY.run("ld.lld -plugin /libraries/arm-none-eabi/liblto_plugin.so -plugin-opt=/libraries/arm-none-eabi/lto-wrapper -plugin-opt=-fresolution=/tmp/ccljymuZ.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lc_nano -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lc_nano -X -o MICROBIT /libraries/arm-none-eabi/thumb/v7e-m+fp/softfp/crti.o /libraries/arm-none-eabi/thumb/v7e-m+fp/softfp/crtbegin.o /libraries/arm-none-eabi-newlib/thumb/v7e-m+fp/softfp/crt0.o -L/libraries/arm-none-eabi-newlib/thumb/v7e-m+fp/softfp -L/libraries/arm-none-eabi-newlib/thumb/v7e-m+fp/softfp -L/libraries/arm-none-eabi/thumb/v7e-m+fp/softfp --gc-sections --wrap atexit --start-group -lstdc++_nano -lsupc++_nano -lgcc -lnosys --end-group ../../lib/codal/../../src/codal_port/filesystem.ld -Map ../../lib/codal/build/MICROBIT.map --start-group ../build/CMakeFiles/MICROBIT.dir/home/johnn333/Documents/micro/micropython-microbit-v2/src/codal_app/main.cpp.o ../build/CMakeFiles/MICROBIT.dir/home/johnn333/Documents/micro/micropython-microbit-v2/src/codal_app/microbithal.cpp.o ../build/CMakeFiles/MICROBIT.dir/home/johnn333/Documents/micro/micropython-microbit-v2/src/codal_app/microbithal_audio.cpp.o ../build/CMakeFiles/MICROBIT.dir/home/johnn333/Documents/micro/micropython-microbit-v2/src/codal_app/microbithal_microphone.cpp.o ../build/CMakeFiles/MICROBIT.dir/home/johnn333/Documents/micro/micropython-microbit-v2/src/codal_app/mphalport.cpp.o ../../lib/codal/build/libcodal-microbit-v2.a ../../lib/codal/build/libcodal-core.a ../../lib/codal/build/libcodal-nrf52.a ../../lib/codal/build/libcodal-microbit-nrf5sdk.a ../../lib/codal/../../src/codal_port/build/libmicropython.a ../../lib/codal/build/libcodal-nrf52.a ../../lib/codal/build/libcodal-core.a ../../lib/codal/libraries/codal-microbit-v2/lib/bootloader.o ../../lib/codal/libraries/codal-microbit-v2/lib/mbr.o ../../lib/codal/libraries/codal-microbit-v2/lib/settings.o ../../lib/codal/libraries/codal-microbit-v2/lib/softdevice.o ../../lib/codal/libraries/codal-microbit-v2/lib/uicr.o -lnosys -lstdc++_nano -lsupc++_nano -lm -lc_nano -lgcc -lstdc++_nano -lsupc++_nano -lm -lc_nano -lgcc --end-group -lstdc++_nano -lm -lc_nano --start-group -lgcc -lc_nano --end-group --start-group -lgcc -lc_nano --end-group /libraries/arm-none-eabi/thumb/v7e-m+fp/softfp/crtend.o /libraries/arm-none-eabi/thumb/v7e-m+fp/softfp/crtn.o -T ../../lib/codal/libraries/codal-microbit-v2/ld/nrf52833-softdevice.ld");
    mPY.run("llvm-objcopy -O ihex MICROBIT MICROBIT.hex");

    // LLD doesnt seem to generate a file compatiable with addlayouttable. This will need looking into and possibly not an easy fix,
    // we already have problems with the linker, with the heap section so a revist here will be necessary. 
    //self.fileSystem.FS.chmod("/src/codal_port/microbit.hex", 0o0444);
    //let e = mPY.run("python ../addlayouttable.py /src/codal_port/microbit.hex ../../lib/codal/build/MICROBIT.map -o MICROBIT.hex");
    self.postMessage({origin:"log", body:"Finished :)"});
    return true;
}


onmessage = async(e) => {
    if(!mPY.initialised) self.postMessage({origin:"log", body:"Loading, Please wait"});
    else{
        buildMicropython();
        self.postMessage({origin: "hex", body: await mPY.getHex()});
    }
}

const mPY = new MicroPython();